#include "sudoku.h"
#include <vector>
/*sudoku::sudoku() {
    tab = new int* [9];
    for (int i = 0; i < 9; i++) {
        tab[i] = new int[9];
    }
}*/

/*sudoku::~sudoku() {
    for (int i = 0; i < 9; i++) {
        delete[] tab[i];
    }
    delete[] tab;
}*/



void sudoku::exampleSudoku() {

   
    int exampleValue[] = {
        5, 3, 0, 0, 7, 0, 0, 0, 0,
        6, 0, 0, 1, 9, 5, 0, 0, 0,
        0, 9, 8, 0, 0, 0, 0, 6, 0,
        8, 0, 0, 0, 6, 0, 0, 0, 3,
        4, 0, 0, 8, 0, 3, 0, 0, 1,
        7, 0, 0, 0, 2, 0, 0, 0, 6,
        0, 6, 0, 0, 0, 0, 2, 8, 0,
        0, 0, 0, 4, 1, 9, 0, 0, 5,
        0, 0, 0, 0, 8, 0, 0, 7, 9
    };

    int k = 0;

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (k >= 81) break;
            tab[i][j] = exampleValue[k];
            k++;
        }
    }

}

void sudoku::printSudoku() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            std::cout << tab[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

void findingSpaces(sudoku& toSolve, int tab[9][9]) {
    toSolve.spaces.clear();
    //znajdywanie pustych miejsc

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (tab[i][j] == 0) {
                toSolve.index.x = i;
                toSolve.index.y = j;
                toSolve.spaces.push_back(toSolve.index);
            }
        }
    }
}
bool checkRowsCols(int tab[9][9], int x, int y) {

    //sprawdzenie dla wiersza (iteruje przez kolumny)
    for (int j = 0; j < 9; j++) {
        if (tab[x][y] == tab[x][j] && y != j && tab[x][y] != 0) {
            //std::cout << "Wartosci w wierszu sie powtarzaja dla: x = " << x << " y = " << y << " oraz x = " << x << " y = " << j <<" wartosc to: "<<toSolve.tab[x][j]<< std::endl;
            //std::cout << "Wartosci powtarzaja sie w wierszu: " << x << std::endl;
            return false;
        }
    }
  
    //sprawdznie dla kolumny (iteruje przez wiersze)

    for (int i = 0; i < 9; i++) {
        if (tab[x][y] == tab[i][y] && x != i && tab[x][y] != 0) {
            //std::cout << "Wartosci w kolumnie sie powtarzaja dla: x = " << x << " y = " << y << " oraz x = " << i << " y = " << y <<" wartosc to: " << toSolve.tab[i][y] << std::endl;
           // std::cout << "Wartosci powtarzaja sie w kolumnie: " << y << std::endl;
            return false;
        }
    }
    return true;
}

bool checkBoxes(int tab[9][9]) {
    int beginRow = 0;
    int beginCol = 0;
    int n = 0;
    
    for (int beginRow = 0; beginRow < 9; beginRow += 3) {
        for (int beginCol = 0; beginCol < 9; beginCol += 3) {
            for (int susVal = 1; susVal < 10; susVal++) {
                n = 0;
                for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (tab[beginRow + i][beginCol + j] == susVal) {
                            n++;
                        }
                        if (n == 2) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}


bool isValid(int tab[9][9]) {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (!checkRowsCols(tab, i, j)) {
                return false;
            }
        }
    }

    if (!checkBoxes(tab)) { return false; };
    

    return true;

}

void solve(sudoku& toSolve) {
    auto it = toSolve.spaces.begin();
    
    while (it != toSolve.spaces.end()) {
        if (toSolve.tab[it->x][it->y] == 0) {
            toSolve.tab[it->x][it->y] = 1;
           // std::cout << "Na miejscu (" << it->x << ", " << it->y << ")" << " wstawilem liczbe " << toSolve.tab[it->x][it->y] << std::endl;
        }
        else {
            toSolve.tab[it->x][it->y]++;
            //std::cout << "Na miejscu (" << it->x << ", " << it->y << ")" << " wstawilem liczbe " << toSolve.tab[it->x][it->y] << std::endl;
        }

        if (toSolve.functionName == "UI") { std::this_thread::sleep_for(std::chrono::milliseconds(1)); }

        if (toSolve.tab[it->x][it->y] > 9) {
            toSolve.tab[it->x][it->y] = 0;
            if (it == toSolve.spaces.begin()) {
                //std::cout << "Sudoku nie rozwiazywalne" << std::endl;
                return;
            }
            it--;
            continue;
        }

        if (isValid(toSolve.tab)) { it++; };
    }
    std::cout << std::endl;
    std::cout << "Sudoku rozwiazne!" << std::endl;
}

bool hasUniqueSolution(sudoku& toSolve,int tempSudoku[9][9]) {
    
    
    auto it = toSolve.spaces.begin();
    int solutions_num = 0;
    while (it != toSolve.spaces.end()) {

        tempSudoku[it->x][it->y]++;
       // std::cout << "Na miejscu (" << it->x << ", " << it->y << ")" << " wstawilem liczbe " << tempSudoku[it->x][it->y] << std::endl;

        if (tempSudoku[it->x][it->y] > 9) {
            tempSudoku[it->x][it->y] = 0;
            if (it == toSolve.spaces.begin() && toSolve.spaces.size() == 1) {
                return true;
            }
            if (it == toSolve.spaces.begin()) {
                //std::cout << "Sudoku nie rozwiazywalne" << std::endl;
                return true;
            }
            it--;
            continue;
        }

        bool valid = isValid(tempSudoku); 

        if (valid) { it++; }
        if (valid && it == toSolve.spaces.end()) {
            solutions_num++;
            if (solutions_num > 2) {
                //std::cout << "Ilosc rozwiazan "<<solutions_num<< std::endl; 
                return false;
            }
                it--;
                continue;
            
        } 
    }
    std::cout <<"Ilosc rozwiazan: "<< solutions_num << std::endl; 
    return true;
}

void generateEmpty(sudoku& toSolve) {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            toSolve.tab[i][j] = 0;

            std::cout << toSolve.tab[i][j] << std::endl;

        }
    }
}
void generateRand(sudoku& toSolve) {
    srand(time(nullptr));
    int number_of_spaces = rand() % 11 + 20;
    int x, y;
    int tempValue = 0;
    int removed = 0;
    int tempSudoku[9][9];

    generateEmpty(toSolve);
    findingSpaces(toSolve, toSolve.tab);
    solve(toSolve);

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            tempSudoku[i][j] = toSolve.tab[i][j];
        }
    }
    findingSpaces(toSolve, tempSudoku);
    
    toSolve.printSudoku();
    std::cout << std::endl;

    while (removed < number_of_spaces) {
        x = rand() % 9;
        y = rand() % 9;

        if (toSolve.tab[x][y] != 0) {
            tempValue = toSolve.tab[x][y];
            toSolve.tab[x][y] = 0;
            tempSudoku[x][y] = 0;


            findingSpaces(toSolve, tempSudoku); 
            std::cout << std::endl;
            if (hasUniqueSolution(toSolve, tempSudoku)) {
                removed++;
            }

            else {
                toSolve.tab[x][y] = tempValue;
                tempSudoku[x][y] = tempValue;
            }
        }
    }
   
    toSolve.printSudoku();
}#ifndef SUDOKU_H
#define SUDOKU_H
#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>
#include <thread>
#include <chrono>

class sudoku {
public:

	int tab[9][9];

	//sudoku();
	//~sudoku();

	struct indexes {
		int x;
		int y;
	}index;

	std::vector<indexes> spaces;
	std::string functionName;

	void exampleSudoku();
	void printSudoku();

	

};
//solving
void findingSpaces(sudoku& toSolve, int tab[9][9]);
bool checkRowsCols(int tab[9][9], int x, int y);
bool checkBoxes(int tab[9][9]);
bool isValid(int tab[9][9]);
void solve(sudoku& toSolve);
//random sudoku
bool hasUniqueSolution(sudoku& toSolve, int tempSudoku[9][9]);
void generateEmpty(sudoku& toSolve);
void generateRand(sudoku& toSolve);

#endif
#ifndef UI_H
#define UI_H
#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include "sudoku.h"
#include <string>
#include <thread>
#include <chrono>
#include "sudoku.h"


class graphics {
public:


	sf::Font font;
	sf::Text text;
	sf::FloatRect textBounds; //zmienna do getLocalBounds (centrowanie liczb) ma sk≈Çadowe .width i .height
	//siatka planszy
	sf::RectangleShape box; 
	std::vector<sf::RectangleShape> boxes;
	sf::Texture backgroundTexture;
	sf::Sprite background;
	
	graphics();

};

void UI(graphics& graphics);

#endif#include "UI.h"

graphics::graphics() {

    
    if (!font.loadFromFile("C:\\Users\\alber\\Desktop\\Projekty\\sudoku\\sudoku\\assets\\arial.ttf")) {
        std::cout << "Blad wczytwyania czcionki" << std::endl;
    }
    else {
        std::cout << "Czcionka wczytana" << std::endl;
    }
    //ustawianie czcionki
    text.setFont(font);
    text.setCharacterSize(30);
    text.setFillColor(sf::Color::Black);
    //ladowanie tla
    if (!backgroundTexture.loadFromFile("C:\\Users\\alber\\Desktop\\Projekty\\sudoku\\sudoku\\assets\\background.png")) {
        std::cout << "Blad wczytwyania tla" << std::endl;
    }
    else {
        std::cout << "Tlo wczytane" << std::endl;
        background.setTexture(backgroundTexture);
    }
    //ustawianie planszy
    box.setSize(sf::Vector2f(80, 80));
    box.setOutlineThickness(5);
    box.setOutlineColor(sf::Color::Black);
  
}
   
void UI(graphics& graphics){

    sudoku sudoku;
    const int boxSize = 80;
    sf::RenderWindow window(sf::VideoMode(1500, 1000), "Sudoku");
    sf::Vector2u windowSize = window.getSize();
    sudoku.functionName = __FUNCTION__;

   
    //tworzenie sudoku
    sudoku.exampleSudoku();
    //generateRand(sudoku);
    findingSpaces(sudoku,sudoku.tab);


   std::thread solver([&sudoku]() {
       solve(sudoku);
       });

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        window.clear(sf::Color::White);
        window.draw(graphics.background);
        graphics.boxes.clear();

        //tworzenie plnaszy z 81 kwadratow 
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                sf::RectangleShape box = graphics.box;
                box.setPosition(windowSize.x / 40 + j * boxSize, windowSize.y / 40 + i * boxSize);
                graphics.boxes.push_back(box);
            }
        }
       
        //rysowanie planszy (81 kwadratow)
       
        for (auto& it : graphics.boxes) {
            window.draw(it);
        }
        
        //wektor do zapisywania wartosci tablicy kazdorzowo ustalanie cech dla value i zapisywanie ich do wektora
        std::vector<sf::Text> values;
        sf::FloatRect numberBounds;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                sf::Text value;
                value.setFont(graphics.font);
                value.setCharacterSize(boxSize/2);
                value.setFillColor(sf::Color(51,133,255));

                if (sudoku.tab[i][j] == 0) {
                    value.setString(" ");
                }
                else {
                    value.setString(std::to_string(sudoku.tab[i][j]));
                }

                numberBounds = value.getLocalBounds();
                value.setOrigin(numberBounds.left + numberBounds.width / 2, numberBounds.top + numberBounds.height / 2);
                value.setPosition(windowSize.x / 40 + (j * boxSize) + boxSize/2, windowSize.y / 40 + (i * boxSize) + boxSize/2);

                values.push_back(value);
            }
        }
        //rysownaie wartosci na planszy

        for (auto& it : values) {
            window.draw(it);
        }
        window.display();
    }
    solver.join();
}#include "sudoku.h"
#include "UI.h"


int main() {

    sudoku sudoku;
    graphics graphics;
    
    //generateRand(sudoku);



    //konwersja sudoku do stringa
    /*
    std::string testTab[81];
    int k = 0;
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (sudoku.tab[i][j] == 0) {
                testTab[k] = ".";
                std::cout << testTab[k];
                k++;
            }
            else {
                testTab[k] = std::to_string(sudoku.tab[i][j]);
                std::cout << testTab[k];
                k++;
            }
            
        }
    }*/ 
    //solve(sudoku);
    //sudoku.printSudoku();
    
    //generateEmpty(sudoku);
    /*sudoku.exampleSudoku();
    sudoku.printSudoku();
    findingSpaces(sudoku);
    hasUniqueSolution(sudoku);
    //solve(sudoku);
    sudoku.printSudoku();*/

   //funckja sprawdza wszystkie indeksy. Zaden nie pasuje
   /* for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            sudoku.tab[i][j] = 0;
            findingSpaces(sudoku);
            if (hasUniqueSolution(sudoku)) {
                
                sudoku.printSudoku();
            }
        }
    }*/
   
   
    
    
    //generateRand(sudoku);
   
    
    /*sudoku.exampleSudoku();
    sudoku.printSudoku();
    findingSpaces(sudoku);
    std::cout << std::endl;
    solve(sudoku);
    std::cout << std::endl;
    sudoku.printSudoku();*/
    
    //UI
    UI(graphics);
    
    
   

    

    return 0;
}












